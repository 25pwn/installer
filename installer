#!/bin/bash
set -e

print() # COLOR TEXT
{
	case $1 in
		"DEFAULT")
			COLORCODE='\e[0m'
			;;
		"RED")
			COLORCODE='\e[31m'
			;;
		"GREEN")
			COLORCODE='\e[32m'
			;;
		"YELLOW")
			COLORCODE='\e[33m'
			;;
		"BLUE")
			COLORCODE='\e[34m'
			;;
		"LRED")
			COLORCODE='\e[91m'
			;;
		"LGREEN")
			COLORCODE='\e[92m'
			;;
		"LYELLOW")
			COLORCODE='\e[93m'
			;;
		"LBLUE")
			COLORCODE='\e[94m'
			;;
	esac
	printf "${COLORCODE}%s\e[0m\n" "$2"
}

log() # LEVEL TEXT
{
	case $1 in
		"debug")
			if [ "$verbosity" -ge "2" ]; then
				print "GREEN" "$2"
			fi
			;;
		"info")
			if [ "$verbosity" -ge "1" ]; then
				print "LGREEN" "$2"
			fi
			;;
		"warning")
			print "LYELLOW" "$2"
			;;
		"error")
			print "LRED" "$2"
			exit 1
			;;
	esac
}

prefixoutput() # OUTPUT
{
	sed "s/^/${1} /"
}

# source:
# https://stackoverflow.com/questions/59895/how-can-i-get-the-source-directory-of-a-bash-script-from-within-the-script-itsel/246128#246128
get_script_prefix()
{
	SOURCE=${BASH_SOURCE[0]}
	while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
		SOURCE=$(readlink "$SOURCE")
		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
	done
	DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
	
	printf "%s" "$DIR"
}

autopart_set_vars()
{
	log "debug" "Retrieving child nodes"
	autopart_dev_list=( $(lsblk ${autopart_dev} -o NAME -ln) )
	efi_dev="/dev/${autopart_dev_list[2]}"
	root_dev="/dev/${autopart_dev_list[3]}"

	if [ ${use_disk_encryption} -eq 1 ]; then
		crypt_dev=${root_dev}
		root_dev="/dev/mapper/${crypt_name}"
		mounts_devices[0]="${root_dev}"
	fi

	grub_efi=1
	grub_bios_dev="${autopart_dev}"

	mounts_points=()
	mounts_devices=()
	mounts_types=()
	mounts_opts=()

	mounts_points+=("/")
	mounts_devices+=("${root_dev}")
	mounts_types+=("btrfs")
	mounts_opts+=("subvol=$btrfssubvol,compress=zstd:0")

	mounts_points+=("/boot/efi")
	mounts_devices+=("${efi_dev}")
	mounts_types+=("vfat")
	mounts_opts+=("defaults")
}

run_autopart()
{
	log "info" "Running autopart"
	log "debug" "Partitioning device"
	sgdisk -Z "${autopart_dev}"
	sgdisk -o "${autopart_dev}"
	sgdisk \
		--new=1:0:+1MiB --typecode=1:ef02 \
		--new=2:0:+128MiB   --typecode=2:EF00 --change-name=2:EFI \
		--new=3:0:0       --typecode=3:8300 --change-name=3:ROOT \
		"${autopart_dev}"
	log "debug" "Running partprobe"
	partprobe "${autopart_dev}"

	log "debug" "Retrieving child nodes"
	autopart_dev_list=( $(lsblk ${autopart_dev} -o NAME -ln) )
	efi_dev="/dev/${autopart_dev_list[2]}"
	root_dev="/dev/${autopart_dev_list[3]}"

	log "debug" "Creating EFI system partition"
	mkfs.vfat -F 32 "${efi_dev}"

	if [ ${use_disk_encryption} -eq 1 ]; then
		log "debug" "Creating LUKS partition"
		crypt_dev=${root_dev}
		root_dev="/dev/mapper/${crypt_name}"
		mounts_devices[0]="${root_dev}"
		printf '%s' "${passphrase}" | cryptsetup luksFormat --type "${crypt_type}" --pbkdf pbkdf2 "${crypt_dev}" --key-file -
		printf '%s' "${passphrase}" | cryptsetup open "${crypt_dev}" "${crypt_name}" --key-file -
	fi

	log "debug" "Creating BTRFS filesystem"
	mkfs.btrfs -f "${root_dev}"

	log "debug" "Creating BTRFS subvolume"
	temp_mountdir="/tmp/installer_mnt"
	mkdir -p "${temp_mountdir}"
	mount "${root_dev}" "${temp_mountdir}" -o compress=zstd:0
	mkdir -p "$(dirname "${temp_mountdir}/${btrfssubvol}")"
	btrfs subvol create "${temp_mountdir}/${btrfssubvol}"
	umount "${root_dev}"
	rm -d "${temp_mountdir}"

	log "debug" "Closing LUKS partition"
	cryptsetup close "${crypt_name}"

	grub_efi=1
	grub_bios_dev="${autopart_dev}"

	mounts_points=()
	mounts_devices=()
	mounts_types=()
	mounts_opts=()

	mounts_points+=("/")
	mounts_devices+=("${root_dev}")
	mounts_types+=("btrfs")
	mounts_opts+=("subvol=$btrfssubvol,compress=zstd:0")

	mounts_points+=("/boot/efi")
	mounts_devices+=("${efi_dev}")
	mounts_types+=("vfat")
	mounts_opts+=("defaults")
}

setup_mounts()
{
	
	
	log "debug" "Setting up mounts"
	root_mnt="/var/lib/machines/$machinename"
	randomid="$(printf '%05d' $RANDOM)" # used to create mountpoints to avoid collisions

	if [ ${use_disk_encryption} -eq 1 ]; then
		log "debug" "Opening $root_dev"
		printf '%s' "${passphrase}" | cryptsetup open "${crypt_dev}" "${crypt_name}" --key-file -
	fi

	for current_mounts_index in ${!mounts_points[@]}; do
		current_mounts_point="${mounts_points[${current_mounts_index}]}"
		current_mounts_device="${mounts_devices[${current_mounts_index}]}"
		current_mounts_type="${mounts_types[${current_mounts_index}]}"
		current_mounts_opt="${mounts_opts[${current_mounts_index}]}"
		
		mkdir -p "${root_mnt}"/"${current_mounts_point}"
		mount "${current_mounts_device}" "$root_mnt/${current_mounts_point}" \
			-t "${current_mounts_type}" -o "${current_mounts_opt}" \
				&& log "debug" "Mounted ${current_mounts_device} to ${current_mounts_point}" \
				|| log "error" "Failed to mount ${current_mounts_device} to ${current_mounts_point}"
	done
}
cleanup_mounts()
{
	if [ ! -d "$root_mnt" ]; then
		return
	fi
	log "debug" "Cleaning up mounts"
	log "debug" "Recursively unmounting $root_mnt"
	umount -R "$root_mnt"
	log "debug" "Removing mountpoint $root_mnt"
	rm -d "$root_mnt"

	if [ ${use_disk_encryption} -eq 1 ]; then
		log "debug" "Closing $root_dev"
		cryptsetup close "${crypt_name}"
	fi
}

bootstrap_system()
{
	log "debug" "Bootstrapping system"
	
	log "debug" "Running pacstrap"
	pacstrap -cGM "$root_mnt" base || log "error" "Failed to bootstrap system"

	log "debug" "Running systemd-firstboot"
	systemd-firstboot \
	--root "$root_mnt" \
	--locale "en_US.UTF-8" \
	--hostname "$machinename" \
	--force || log "error" "Failed to initially configure system"
}

start_container()
{
	log "debug" "Configuring container"

	mkdir -p "/etc/systemd/system/systemd-nspawn@$machinename.service.d"
	cp "$configdir/nspawn/override.conf" \
	"/etc/systemd/system/systemd-nspawn@$machinename.service.d/overrride.conf"

	mkdir -p "/etc/systemd/nspawn"
	cp "$configdir/nspawn/machinename.nspawn" \
	"/etc/systemd/nspawn/$machinename.nspawn"

	log "debug" "Starting Container"
	machinectl start "$machinename" && log "debug" "Started container"
}
poweroff_container()
{
	container_status="$(systemctl show "systemd-nspawn@$machinename" -P StatusText)"
	if [ "$container_status" != "Container running: Ready." ]; then
		return
	fi

	log "debug" "Shutting down container"
	machinectl poweroff "$machinename"
	
	log "debug" "Cleaning up container configurations"
	rm -rf "/etc/systemd/system/systemd-nspawn@$machinename.service.d"
	rm -f "/etc/systemd/nspawn/$machinename.nspawn"
}

run_commands() # HYPERVISOR USER < COMMANDS
{
	if [ ${verbosity} -ge 3 ]; then
		prefix_commands='set -xe'
	else
		prefix_commands='set -e'
	fi
	case $1 in
		"arch-chroot")
			if [ "$2" != "root" ]; then
				userarg="-u $2"
			fi

			arch-chroot \
			$userarg "$root_mnt" \
			bash <<- ENDOFSCRIPT
			${prefix_commands}
			$(cat /dev/stdin)
			ENDOFSCRIPT
			;;
		"systemd-nspawn")
			if [ "$2" != "root" ]; then
				userflag="--user"
			fi

			systemd-run \
			$userflag -PM "$2"@"$machinename" \
			bash <<- ENDOFSCRIPT
			${prefix_commands}
			$(cat /dev/stdin)
			ENDOFSCRIPT
			;;
	esac
}

run_script() # HYPERVISOR USER SCRIPT
{
	run_commands $1 $2 <<-ENDOFSCRIPT
	$(cat "$configdir/scripts/$3/script")
	ENDOFSCRIPT
}

run_new_scripts()
{	
	log "debug" "Running container_scripts scripts"
	for script in $container_scripts; do
		log "debug" "Running $script script"
		scriptdir="$configdir/scripts/${script}"
		if [ -r  "${scriptdir}/newscript" ]; then
			source "${scriptdir}/newscript" \
			|| log "error" "Failed to run $script"
		else
			run_script "systemd-nspawn" "root" "$script" \
			|| log "error" "Failed to run $script"
		fi

	done
	
	log "debug" "Running user_container_scripts scripts"
	for script in $user_container_scripts; do
		log "debug" "Running $script script"
		scriptdir="$configdir/scripts/${script}"
		if [ -r  "${scriptdir}/newscript" ]; then
			source "${scriptdir}/newscript" \
			|| log "error" "Failed to run $script"
		else
			run_script "systemd-nspawn" "$username" "$script" \
			|| log "error" "Failed to run $script"
		fi
	done
	
	log "debug" "Running arch_chroot_scripts scripts"
	for script in $arch_chroot_scripts; do
		log "debug" "Running $script script"
		scriptdir="$configdir/scripts/${script}"
		if [ -r  "${scriptdir}/newscript" ]; then
			source "${scriptdir}/newscript" \
			|| log "error" "Failed to run $script"
		else
			run_script "arch-chroot" "root" "$script" \
			|| log "error" "Failed to run $script"
		fi
	done

	log "debug" "Showing disk usage"
	run_commands "systemd-nspawn" "root" <<- ENDOFSCRIPT
	btrfs fi usage /
	ENDOFSCRIPT
}

install()
{
	log "info" "Starting install"

	if [ ${autopart} -eq 1 ]; then
		run_autopart
	fi

	setup_mounts

	bootstrap_system

	start_container
	run_new_scripts
	poweroff_container

	if [ "$verbosity" -ge "2" ]; then
		log "debug" "Showing install size"
		log "debug" "$(du -hs "$root_mnt")"
	fi
	
	cleanup_mounts

	log "info" "Finished install"
}

uninstall()
{
	log "info" "Starting uninstall"

	if [ ${autopart} -eq 1 ]; then
		autopart_set_vars
	fi
	setup_mounts

	for ((i=${#mounts_points[@]}-1; i>=0; i--)); do
		log "debug" "Clearing ${mounts_points[${i}]}"
		rm -rf "${root_mnt}/${mounts_points[${i}]}"
		log "debug" "Unmounting ${mounts_points[${i}]}"
		umount "${root_mnt}/${mounts_points[${i}]}"
	done

	rm -d "${root_mnt}"

	cleanup_mounts

	log "info" "Finished uninstall"
}

reinstall()
{
	log "info" "Starting reinstall"
	uninstall
	install
	log "info" "Finished reinstall"
}

nshell()
{
	if [ ${autopart} -eq 1 ]; then
		autopart_set_vars
	fi
	setup_mounts
	start_container
	log "info" "Entering container"
	machinectl shell "root"@"$machinename" 
	log "info" "Exited container"
	poweroff_container
	cleanup_mounts
}

cshell()
{
	if [ ${autopart} -eq 1 ]; then
		autopart_set_vars
	fi
	setup_mounts
	log "info" "Entering chroot"
	arch-chroot "$root_mnt" bash
	log "info" "Exited chroot"
	cleanup_mounts
}

cleanup_script()
{
	log "debug" "Running script cleanup"

	poweroff_container
	cleanup_mounts

	trap - EXIT
	trap - SIGINT

	log "debug" "Exiting"
	exit
}

exit_hook()
{
	print "LRED" "Running exit hook"
	cleanup_script
}

sigint_hook()
{
	print "LRED" "Running sigint hook"
	cleanup_script
}

setup_script()
{
	trap "exit_hook" EXIT
	trap "sigint_hook" SIGINT
}

parse_args() # ACTION CONFIG
{
	if [ "$EUID" != "0" ]; then
		log "error" "Insufficient Privileges"
	elif [ "$*" == "" ]; then
		log "error" "No arguments specified"
	elif [ "$1" != "" ]; then
		valid_action="0"
		for action in install uninstall reinstall nshell cshell; do
			if [ "$1" == "$action" ]; then
				valid_action="1"
			fi
		done
		if [ "$valid_action" == "0" ]; then
			log "error" "Invalid action"
		fi
	elif [ "$2" == "" ]; then
		log "error" "No config folder specified"
	elif [ ! -f "$2/config" ]; then
		log "error" "Config file $2/config does not exist"
	fi

	script_action="$1"

	scriptprefix="$(get_script_prefix)"

	defaultconfigfile="$scriptprefix/configs/defaults/config"
	default_config_contents="$(cat "${defaultconfigfile}")"
	source "$defaultconfigfile"

	configfile="$2/config"
	config_contents="$(cat "${configfile}")"
	source "$configfile"


	unset="0"
	for var in configdir distro machinename; do
    	if [ "${!var}" == "" ]; then
        	log "warning" "$var is unset"
        	unset="1"
    	fi
	done

	if [ "$unset" == "1" ]; then
    	log "error" "Insufficient configuration"
	fi

	if [ ${verbosity} -ge 3 ]; then
		set -xe
	fi

	if [ "$sourced" == 0 ]; then
		setup_script
		"$script_action"
		cleanup_script
	else
		setup_script
	fi
}

# sources:
# https://stackoverflow.com/a/28776166/18379499
# https://unix.stackexchange.com/a/220840/517083
if [ "$(return 0 2>/dev/null; printf "%s" "$?")" ]; then
	sourced=0
	parse_args "$@"
else
	sourced=1
fi
